\subsection{Relational Operator Replacement}

\begin{table}
  \centering
  \begin{tabular}{l l l l l l l}
    \toprule
              & \multicolumn{6}{c}{Replacement}                                                         \\
    \cmidrule(r){2-7}
    Original  & \java{>}     & \java{>=}    & \java{==}    & \java{<=}    & \java{<}     & \java{!=}    \\
    \midrule
    \java{>}  &              & \checkmark{} & \checkmark{} & \checkmark{} & \checkmark{} & \checkmark{} \\
    \java{>=} & \checkmark{} &              & \checkmark{} & \checkmark{} & \checkmark{} & \checkmark{} \\
    \java{==} & \checkmark{} & \checkmark{} &              & \checkmark{} & \checkmark{} & \checkmark{} \\
    \java{<=} & \checkmark{} & \checkmark{} & \checkmark{} &              & \checkmark{} & \checkmark{} \\
    \java{<}  & \checkmark{} & \checkmark{} & \checkmark{} & \checkmark{} &              & \checkmark{} \\
    \java{!=} & \checkmark{} & \checkmark{} & \checkmark{} & \checkmark{} & \checkmark{} &              \\
    \bottomrule
  \end{tabular}
  \caption[ROR mutations]{Relational operator replacement mutations}
  \label{tab:ror:src_ops}
\end{table}

The relational operator replacement (ROR) mutator performs bytecode mutations equivalent to the source code mutations listed in Table~\ref{tab:ror:src_ops}.
Each of the source-level ordered inequality operators (\java{>}, \java{>=}, \java{==}, \java{<=}, and \java{<}) has two corresponding bytecode opcodes, one that has two operands and one that compares a single operand to the zero value.
For example, the \java{!=} operator in source code can be compiled to the opcode \path{IF_ICMPNE} or \path{IFNE} that check for inequality between two operands and check for inequality between a single operand and zero, respectively.
The ROR mutator must use all of the bytecode-level ordered inequality operators in its implementation of \java{MethodVisitor}.

Other implementations of ROR mutators manually list every replacement opcode for every source-level relational operator~\cite{ProdigyXable}.
This results in a large amount of code duplication, much of which is unavoidable due to the \java{Map} returned being \java{static}.
However, we were able to reduce the number of changes required between each implementation by storing the bytecode relational operators in enums and iterating over those operators, adding to the \java{Map} only when the loop's current opcode is not the opcode being replaced.
Listing~\ref{lst:ror:enum} shows an excerpt of the enumeration of the zero-comparing opcodes.
Listing~\ref{lst:ror:MethodVisitor} shows one of the enum iterations from the ROR mutator's \java{MethodVisitor}.

\begin{lstlisting}[%
  language=Java,
  frame=tb,
  caption={%
    enum excerpt from the ROR mutator.
    The \java{Opcodes} enum is imported from the package \java{org.objectweb.asm.Opcodes}.
  },
  captionpos=b,
  label={lst:ror:enum}]
enum OpcodeCompareToZero {
  IFEQ(Opcodes.IFEQ) {
    public String toString() {
      return "==";
    }
  },
  // ...
  IFNE(Opcodes.IFNE) {
    public String toString() {
      return "!=";
    }
  };

  private final int opcode;

  OpcodeCompareToZero(int opcode) {
    this.opcode = opcode;
  }

  public int getOpcode() {
    return this.opcode;
  }
}
\end{lstlisting}

\begin{lstlisting}[%
  language=Java,
  frame=tb,
  caption={%
    Excerpt of the implementation of \java{MethodVisitor} for the ROR mutator.
    The value of \java{REPLACEMENT_OP} has been previously declared to be an opcode.
  },
  captionpos=b,
  label={lst:ror:MethodVisitor}]
// The operands will seem to be in the wrong
// order when used in else conditions.
// To the bytecode parser, though, this is
// not the case.
for (OpcodeCompareToZero original
    : OpcodeCompareToZero.values()) {
  if (REPLACEMENT_OP != original) {
    MUTATIONS.put(
      original.getOpcode(),
      new Substitution(
        REPLACEMENT_OP.getOpcode(),
        "Relational operator replacement: "
        + "Mutated " + original
        + " to " + REPLACEMENT_OP));
  }
}
\end{lstlisting}
